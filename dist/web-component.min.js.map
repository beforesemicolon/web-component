{
  "version": 3,
  "sources": ["../src/directives/registry.ts", "../src/metadata.ts", "../src/utils/define-node-context-metadata.ts", "../src/directive.ts", "../src/directives/if.directive.ts", "../src/directives/ref.directive.ts", "../src/utils/turn-kebab-to-camel-casing.ts", "../src/utils/turn-camel-to-kebab-casing.ts", "../src/directives/attr.directive.ts", "../src/utils/parse.ts", "../src/directives/repeat.directive.ts", "../src/directives/index.ts", "../src/utils/proxify.ts", "../src/utils/json-parse.ts", "../src/utils/set-component-properties-from-observed-attributes.ts", "../src/utils/setup-component-properties-for-auto-update.ts", "../src/utils/get-style-string.ts", "../src/enums/ShadowRootModeExtended.enum.ts", "../src/utils/extract-executable-snippet-from-string.ts", "../src/utils/parse-node-directive.ts", "../src/utils/evaluate-string-in-component-context.ts", "../src/utils/resolve-executable.ts", "../src/utils/get-component-node-event-listener.ts", "../src/utils/get-event-handler-function.ts", "../src/node-track.ts", "../src/utils/track-node.ts", "../src/web-component.ts", "../src/context-provider-component.ts", "../src/client.ts"],
  "sourcesContent": ["export const directiveRegistry: {[key: string]: DirectiveConstructor} = {};\n", "/**\n * metadata is a simple global object that is used to store data related to the node\n * to prevent attaching properties on the node directly also to prevent this data\n * to be manipulated when user has reference of the node object.\n *\n * its weak nature also means that when no node reference exists, these data will simply be\n * garbage collected\n */\nexport const $: WeakMap<any, any> = new WeakMap();\n", "import {$} from \"../metadata\";\n\nexport function defineNodeContextMetadata(node: Node) {\n\tif ($.get(node)?.$context) {\n\t\treturn;\n\t}\n\n\tif (!$.has(node)) {\n\t\t$.set(node, {});\n\t}\n\n\tlet ctx: {[key: string]: any} = {};\n\n\tObject.defineProperty($.get(node), '$context', {\n\t\tget() {\n\t\t\t// all node context is shared with children deeply\n\t\t\t// and this allows that\n\t\t\treturn {...$.get(node.parentNode)?.$context, ...ctx};\n\t\t}\n\t})\n\n\t$.get(node).updateContext = (newCtx: ObjectLiteral) => {\n\t\tif (typeof newCtx === 'object') {\n\t\t\tctx = {...ctx, ...newCtx};\n\t\t}\n\t}\n}\n", "import {directiveRegistry} from \"./directives/registry\";\nimport {$} from \"./metadata\";\nimport {defineNodeContextMetadata} from \"./utils/define-node-context-metadata\";\n\nexport class Directive {\n\tconstructor(component: WebComponent) {\n\t\t$.set(this, {component})\n\t}\n\n\tstatic register(name: string = '') {\n\t\tname = (name || this.name).toLowerCase();\n\n\t\tif (directiveRegistry[name] === undefined) {\n\t\t\tdirectiveRegistry[name] = this;\n\t\t}\n\t}\n\n\tparseValue(value: string, prop: string | null) {\n\t\treturn value;\n\t}\n\n\trender(val: unknown, {element}: directiveRenderOptions): directiveRenderOptions['anchorNode'] {\n\t\treturn element;\n\t}\n\n\tsetRef(name: string, node: Node) {\n\t\t$.get(this).component.$refs[name] = node;\n\t}\n\n\tgetContext(node: Node) {\n\t\treturn $.get(node).$context ?? null;\n\t}\n\n\tupdateContext(node: Node, newCtx: ObjectLiteral) {\n\t\tdefineNodeContextMetadata(node);\n\t\t$.get(node)?.updateContext(newCtx);\n\t}\n}\n", "import {Directive} from \"../directive\";\n\nexport class If extends Directive {\n\trender(condition: boolean, {element, anchorNode}: directiveRenderOptions) {\n\t\treturn condition\n\t\t\t? element\n\t\t\t: (anchorNode || new Comment(` if: ${condition} `));\n\t}\n}\n\n", "import {Directive} from \"../directive\";\n\nexport class Ref extends Directive {\n\tparseValue(value: string): string {\n\t\treturn `\"${value}\"`;\n\t}\n\n\trender(name: string, {element}: directiveRenderOptions) {\n\t\tif (/^[a-z$_][a-z0-9$_]*$/i.test(name)) {\n\t\t\tthis.setRef(name, element);\n\t\t\treturn element;\n\t\t}\n\n\t\tthrow new Error(`Invalid \"ref\" property name \"${name}\"`)\n\t}\n}\n\n", "export function turnKebabToCamelCasing(name: string): string {\n\treturn name\n\t\t.split(/-+/)\n\t\t.map((part, i) => i === 0 && part.length > 1 ? part : part[0].toUpperCase() + part.slice(1))\n\t\t.join('') ?? name;\n}", "export function turnCamelToKebabCasing(name: string): string {\n\treturn name\n\t\t.match(/(?:[A-Z]+(?=[A-Z][a-z])|[A-Z]+|[a-zA-Z])[a-z]*/g)\n\t\t?.map(p => p.toLowerCase())\n\t\t.join('-') ?? name;\n}\n", "import {Directive} from \"../directive\";\nimport {turnKebabToCamelCasing} from \"../utils/turn-kebab-to-camel-casing\";\nimport {turnCamelToKebabCasing} from \"../utils/turn-camel-to-kebab-casing\";\nimport booleanAttr from \"../utils/boolean-attributes.json\";\n\nexport class Attr extends Directive {\n\tparseValue(value: string, prop: string | null): string {\n\t\tlet [attrName, property = null] = (prop ?? '').split('.');\n\t\tconst commaIdx = value.lastIndexOf(',');\n\n\t\treturn `[\"${attrName}\", \"${property || ''}\", ${commaIdx >= 0 ? value.slice(commaIdx + 1).trim() : value}, \"${commaIdx >= 0 ? value.slice(0, commaIdx).trim() : ''}\"]`;\n\t}\n\n\trender([attrName, property, shouldAdd, val]: any, {element}: directiveRenderOptions): HTMLElement {\n\t\tswitch (attrName) {\n\t\t\tcase 'style':\n\t\t\t\tif (property) {\n\t\t\t\t\tproperty = turnKebabToCamelCasing(property);\n\n\t\t\t\t\telement.style[property] = shouldAdd ? val : '';\n\t\t\t\t} else {\n\t\t\t\t\tval\n\t\t\t\t\t\t.match(/([a-z][a-z-]+)(?=:):([^;]+)/g)\n\t\t\t\t\t\t?.forEach((style: string) => {\n\t\t\t\t\t\t\tlet [name, styleValue] = style.split(':').map(s => s.trim());\n\n\t\t\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\t\t\telement.style.setProperty(name, styleValue);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telement.setAttribute(\n\t\t\t\t\t\t\t\t\t'style',\n\t\t\t\t\t\t\t\t\telement.style.cssText.replace(new RegExp(`${name}\\\\s*:\\\\s*${styleValue};?`, 'g'), ''))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'class':\n\t\t\t\tif (property) {\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\telement.classList.add(property);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.classList.remove(property);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst classes = val.split(/\\s+/g);\n\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\tclasses.forEach((cls: string) => element.classList.add(cls));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclasses.forEach((cls: string) => element.classList.remove(cls));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tif (property) {\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\telement.dataset[turnKebabToCamelCasing(property)] = val;\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.removeAttribute(`data-${turnCamelToKebabCasing(property)}`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (attrName) {\n\t\t\t\t\tif (shouldAdd) {\n\t\t\t\t\t\telement.setAttribute(attrName,\n\t\t\t\t\t\t\tbooleanAttr.hasOwnProperty(attrName) ? '' : `${val || shouldAdd}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.removeAttribute(attrName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t}\n}\n", "import selfClosingTags from './self-closing-tags.json';\n\nexport function parse(markup: string) {\n\tconst tagCommentPattern = /<!--([^]*?)-->|<(\\/|!)?([a-z][\\w-.:]*)((?:\\s*[a-z][\\w-.:]*(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'))?)+\\s*|\\s*)(\\/?)>/ig;\n\tconst root = document.createDocumentFragment();\n\tconst stack: Array<DocumentFragment | HTMLElement> = [root];\n\tlet match: RegExpExecArray | null = null;\n\tlet lastIndex = 0;\n\n\twhile ((match = tagCommentPattern.exec(markup)) !== null) {\n\t\tlet [fullMatch, comment, closeOrBangSymbol, tagName, attributes, selfCloseSlash] = match;\n\n\t\ttagName = tagName?.toUpperCase();\n\n\t\tif (closeOrBangSymbol === '!') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst parentNode = stack[stack.length - 1] || null;\n\n\t\t// grab in between text\n\t\tif (lastIndex !== match.index) {\n\t\t\tconst textNode = document.createTextNode(markup.slice(lastIndex, match.index));\n\t\t\tparentNode.appendChild(textNode);\n\t\t}\n\n\t\tlastIndex = tagCommentPattern.lastIndex;\n\n\t\tif (comment) {\n\t\t\tconst commentNode = document.createComment(comment);\n\t\t\tparentNode.appendChild(commentNode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (selfCloseSlash || (selfClosingTags as {[key: string]: string})[tagName]) {\n\t\t\tconst node = document.createElement(tagName);\n\n\t\t\tsetAttributes(node, attributes)\n\n\t\t\tparentNode.appendChild(node);\n\t\t} else if (closeOrBangSymbol === '/') {\n\t\t\tstack.pop();\n\t\t} else if (!closeOrBangSymbol) {\n\t\t\tconst node = document.createElement(tagName);\n\n\t\t\tsetAttributes(node, attributes)\n\n\t\t\tparentNode.appendChild(node);\n\n\t\t\tstack.push(node)\n\t\t}\n\t}\n\n\t// grab ending text\n\tif (lastIndex < markup.length) {\n\t\tconst textNode = document.createTextNode(markup.slice(lastIndex));\n\t\troot.appendChild(textNode);\n\t}\n\n\treturn root;\n}\n\nfunction setAttributes(node: HTMLElement, attributes: string) {\n\tconst attrPattern = /([a-z][\\w-.:]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n\tlet match: RegExpExecArray | null = null;\n\n\twhile ((match = attrPattern.exec(attributes))) {\n\t\tlet name = match[1];\n\t\tconst value = match[2] || match[3] || match[4] || (\n\t\t\tnew RegExp(`^${match[1]}\\\\s*=`).test(match[0]) ? '' : null\n\t\t)\n\n\t\tnode.setAttribute(name, value ?? '');\n\t}\n}\n", "import {Directive} from \"../directive\";\nimport {parse} from \"../utils/parse\";\n\nexport class Repeat extends Directive {\n\tparseValue(value: string): string {\n\t\tconst idx = value.lastIndexOf(';');\n\t\tlet iPart = value;\n\t\tlet kPart = '';\n\t\t\n\t\tif (idx > 0) {\n\t\t\tiPart = value.slice(0, idx);\n\t\t\tkPart = value.slice(idx + 1);\n\t\t}\n\t\t\n\t\tconst [v, vAs = \"$item\"] = `${iPart} `.split(/\\s+as\\s+/g).map(s => s.trim());\n\t\tconst [k, kAs = \"$key\"] = `${kPart} `.split(/\\s+as\\s+/g).map(s => s.trim());\n\t\t\n\t\treturn `[${v}, \"${vAs}\", \"${k === '$key' ? kAs : ''}\"]`;\n\t}\n\t\n\trender([repeatData, vAs, kAs]: any, {element, rawElementOuterHTML, anchorNode}: directiveRenderOptions) {\n\t\tanchorNode = (anchorNode ?? []) as Array<Element>;\n\t\tconst list: Array<Element> = [];\n\n\t\tif (element.nodeType === 1) {\n\t\t\tlet times: number;\n\n\t\t\tif (Number.isInteger(repeatData)) {\n\t\t\t\ttimes = repeatData;\n\t\t\t} else {\n\t\t\t\trepeatData = repeatData instanceof Set ? Object.entries(Array.from(repeatData))\n\t\t\t\t\t: repeatData instanceof Map ? Array.from(repeatData.entries())\n\t\t\t\t\t\t: repeatData[Symbol.iterator] ? Object.entries([...repeatData])\n\t\t\t\t\t\t\t: Object.entries(repeatData);\n\t\t\t\ttimes = repeatData.length;\n\t\t\t}\n\n\t\t\tfor (let index = 0; index < times; index++) {\n\t\t\t\tif (anchorNode[index]) {\n\t\t\t\t\tthis.updateNodeContext(anchorNode[index], index, vAs, kAs, repeatData);\n\t\t\t\t\tlist.push(anchorNode[index]);\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst el = this.cloneRepeatedNode(rawElementOuterHTML);\n\t\t\t\tthis.updateNodeContext(el, index, vAs, kAs, repeatData)\n\t\t\t\tlist.push(el);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n\t\n\tupdateNodeContext(el: Node, index: number, vAs: string, kAs: string, list: Array<any> = []) {\n\t\tconst [key, value] = list[index] ?? [index, index + 1];\n\t\t// set context so this and inner nodes can catch these values\n\t\tthis.updateContext(el, {\n\t\t\t[vAs || '$item']: value,\n            [kAs || '$key']: key\n\t\t});\n\t}\n\n\tcloneRepeatedNode(rawElementOuterHTML: string): Element {\n\t\tconst clone = parse(rawElementOuterHTML).children[0];\n\t\t// remove the repeat node to avoid infinite loop where the clone node also repeat\n\t\tclone.removeAttribute('repeat');\n\t\t// remove the if because the if directive is execute before any directive\n\t\t// which means if the node reached the repeat, it was already processed by possibly\n\t\t// existing if directive\n\t\tclone.removeAttribute('if');\n\t\t\n\t\treturn clone;\n\t}\n}\n\n", "import {If} from './if.directive';\nimport {Ref} from './ref.directive';\nimport {Attr} from './attr.directive';\nimport {Repeat} from './repeat.directive';\n\nIf.register('if');\nRef.register('ref');\nAttr.register('attr');\nRepeat.register('repeat');\n\nexport const directives = new Set([\n\tIf.name.toLowerCase(),\n\tRef.name.toLowerCase(),\n\tAttr.name.toLowerCase(),\n\tRepeat.name.toLowerCase(),\n])\n", "export function proxify(name: string, object: any, notify: (name: string, o: any) => void = () => {\n}, self = null): any {\n\tself = self ?? object;\n\n\tif (\n\t\t!object ||\n\t\tobject.__proxy__ ||\n\t\t/number|function|string|bigint|boolean/.test(typeof object) ||\n\t\t[String, Number, Boolean, BigInt].some(o => object instanceof o)\n\t) {\n\t\treturn object;\n\t}\n\n\treturn new Proxy(object, {\n\t\tget(obj, n: string) {\n\t\t\tlet res = Reflect.get(obj, n);\n\n\t\t\tif (res) {\n\t\t\t\tif (typeof res === 'object') {\n\t\t\t\t\treturn proxify(name, res, notify, self);\n\t\t\t\t}\n\n\t\t\t\tif (typeof res === 'function') {\n\t\t\t\t\tif (typeof n !== 'symbol') {\n\t\t\t\t\t\t// for each can be used to loop over the properties of an object\n\t\t\t\t\t\t// to change the value of each property which is the reason to proxify the items\n\t\t\t\t\t\t// but the same cannot be said to methods like map, reduce and filter\n\t\t\t\t\t\t// which return a new object and not the original one so for those\n\t\t\t\t\t\t// to have the change event triggered, the return objects must be used to replace the object\n\t\t\t\t\t\t// and get proxified in the process\n\t\t\t\t\t\tif (/forEach/.test(n)) {\n\t\t\t\t\t\t\treturn (cb: (v: any, k: number, l: any) => void, thisArg?: any) => {\n\t\t\t\t\t\t\t\tobj[n]((v: any, k: number, l: any) => {\n\t\t\t\t\t\t\t\t\tcb.call(thisArg ?? obj, proxify(name, v, notify, self), k, l);\n\t\t\t\t\t\t\t\t}, thisArg ?? obj);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (/values|entries|keys/.test(n)) {\n\t\t\t\t\t\t\t// keys need to also be proxified becuase they may be objects which are used in the\n\t\t\t\t\t\t\t// template for rendering\n\t\t\t\t\t\t\treturn () => ({\n\t\t\t\t\t\t\t\t*[Symbol.iterator]() {\n\t\t\t\t\t\t\t\t\tif (n === 'entries') {\n\t\t\t\t\t\t\t\t\t\tfor (const [k, v] of obj[n]()) {\n\t\t\t\t\t\t\t\t\t\t\tyield [proxify(name, k, notify, self), proxify(name, v, notify, self)];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfor (const v of obj[n]()) {\n\t\t\t\t\t\t\t\t\t\t\tyield proxify(name, v, notify, self);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn (...args: any[]) => {\n\t\t\t\t\t\t\tconst r = res.apply(obj, args);\n\n\t\t\t\t\t\t\t// reading any item while it is still in the object should be proxified\n\t\t\t\t\t\t\t// to allow for detecting changes\n\t\t\t\t\t\t\tif (typeof r === 'object' && (\n\t\t\t\t\t\t\t\t(Array.isArray(obj) && /at|find/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof Map) && /get/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof WeakMap) && /get/.test(n))\n\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\treturn proxify(name, r, notify, self);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// this is done under the assumption that the function\n\t\t\t\t\t\t\t// will always update the object\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(Array.isArray(obj) && /push|pop|splice|shift|unshift|reverse|sort|fill|copyWithin/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof Map) && /set|delete|clear/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof Set) && /add|delete|clear/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof WeakSet) && /add|delete/.test(n)) ||\n\t\t\t\t\t\t\t\t((obj instanceof WeakMap) && /set|delete/.test(n))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnotify(name, self);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// make sure the object it bound to the function for when it is called\n\t\t\t\t\t\tres = res.bind(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\t\tset(obj, n: string, value) {\n\t\t\tconst res = Reflect.set(obj, n, value);\n\n\t\t\tnotify(name, self);\n\n\t\t\treturn res;\n\t\t},\n\t\tdeleteProperty(target: any, p: string | symbol): boolean {\n            const res = Reflect.deleteProperty(target, p);\n\n            notify(name, self);\n\n            return res;\n        },\n\t\tdefineProperty(target: any, p: string | symbol, attributes: PropertyDescriptor): boolean {\n            const res = Reflect.defineProperty(target, p, attributes);\n\n            notify(name, self);\n\n            return res;\n        },\n\t});\n}\n", "export function jsonParse(value: string): any {\n\tif (value && typeof value === 'string') {\n\t\ttry {\n\t\t\tvalue = JSON.parse(value.replace(/['`]/g, '\"'));\n\t\t} catch (e) {\n\t\t}\n\t}\n\n\treturn value;\n}", "import {turnKebabToCamelCasing} from './turn-kebab-to-camel-casing';\nimport {proxify} from './proxify';\nimport boolAttr from './boolean-attributes.json';\nimport {directives} from \"../directives\";\nimport {jsonParse} from \"./json-parse\";\n\nexport function setComponentPropertiesFromObservedAttributes(\n\tcomponent: HTMLElement,\n\tobservedAttributes: string[],\n\tonUpdate: onUpdateCallback\n): string[] {\n\tconst properties: string[] = [];\n\n\tobservedAttributes.forEach(prop => {\n\t\tprop = prop.trim();\n\n\t\tif (!directives.has(prop) && !(prop.startsWith('data-') || prop === 'class' || prop === 'style')) {\n\t\t\tlet value: string | boolean = component.getAttribute(prop) ?? '';\n\t\t\tprop = turnKebabToCamelCasing(prop);\n\n\t\t\tproperties.push(prop);\n\n\t\t\tvalue = proxify(prop, jsonParse(value), (name, val) => {\n\t\t\t\tonUpdate(name, val, val);\n\t\t\t})\n\t\t\t\n\t\t\tif ((boolAttr).hasOwnProperty(prop)) {\n\t\t\t\tvalue = (boolAttr as booleanAttributes)[prop].value;\n\t\t\t\tprop = (boolAttr as booleanAttributes)[prop].name;\n\t\t\t}\n\n\t\t\tObject.defineProperty(component, prop, {\n\t\t\t\tget() {\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tset(newValue) {\n\t\t\t\t\tif (value !== newValue) {\n\t\t\t\t\t\tconst oldValue = value;\n\t\t\t\t\t\tvalue = proxify(prop, newValue, () => {\n\t\t\t\t\t\t\tonUpdate(prop, oldValue, value);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tonUpdate(prop, oldValue, newValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\treturn properties;\n}\n", "import {turnCamelToKebabCasing} from \"./turn-camel-to-kebab-casing\";\nimport {directives} from \"../directives\";\nimport {proxify} from \"./proxify\";\n\nexport function setupComponentPropertiesForAutoUpdate(component: WebComponent, onUpdate: onUpdateCallback): string[] {\n\tconst properties: string[] = [];\n\n\tfor (let property of Object.getOwnPropertyNames(component)) {\n\t\tconst attr = turnCamelToKebabCasing(property);\n\n\t\t// ignore private properties and $ properties as well as attribute properties\n\t\tif (!directives.has(property) && !/\\$|_/.test(property[0]) && !(component.constructor as WebComponentConstructor).observedAttributes.includes(attr)) {\n\t\t\t// @ts-ignore\n\t\t\tlet value = component[property];\n\n\t\t\tproperties.push(property);\n\n\t\t\tvalue = proxify(property, value, () => {\n\t\t\t\tonUpdate(property, value, value);\n\t\t\t})\n\n\t\t\tObject.defineProperty(component, property, {\n\t\t\t\tget() {\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tset(newValue) {\n\t\t\t\t\tconst oldValue = value;\n\t\t\t\t\tvalue = proxify(property, newValue, () => {\n\t\t\t\t\t\tonUpdate(property, oldValue, value);\n\t\t\t\t\t});\n\n\t\t\t\t\tif (newValue !== oldValue) {\n\t\t\t\t\t\tonUpdate(property, oldValue, newValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\treturn properties;\n}\n", "export function getStyleString(stylesheet: string, tagName: string, hasShadowRoot: boolean = true) {\n\tstylesheet = stylesheet.trim().replace(/\\s{2,}/g, ' ');\n\n\tif (!stylesheet) {\n\t    return '';\n\t}\n\n\tlet style = stylesheet.startsWith('<style')\n\t\t? stylesheet\n\t\t: `<style>${stylesheet}</style>`;\n\n\tconst div = document.createElement('div');\n\n\tif (!hasShadowRoot) {\n\t\tstyle = style.replace(/(:host)((\\s*\\(.*\\)|))?/g, (_, h, s) => {\n\t\t\tif (s) {\n\t\t\t\treturn tagName + s.trim().slice(1, -1).trim();\n\t\t\t}\n\t\t\treturn tagName;\n\t\t})\n\t}\n\n\tdiv.innerHTML = style;\n\n\tArray.from(div.children).forEach(child => {\n\t\tchild.className = tagName;\n\t});\n\n\treturn div.innerHTML;\n}\n", "export enum ShadowRootModeExtended  {\n\tOPEN = 'open',\n\tCLOSED = 'closed',\n\tNONE = 'none',\n}\n", "export function extractExecutableSnippetFromString(str: string, [start, end] = ['{', '}']) {\n\tconst stack = [];\n\tconst pattern = new RegExp(`[\\\\${start}\\\\${end}]`, 'g');\n\tlet snippets: Executable[] = [];\n\tlet match;\n\tlet startingCurlyIndex: number;\n\n\twhile ((match = pattern.exec(str)) !== null) {\n\t\tconst char = match[0];\n\n\t\tif (char === start) {\n\t\t\tstack.push(match.index);\n\t\t} else if (char === end && stack.length) {\n\t\t\tstartingCurlyIndex = stack.pop() as number;\n\n\t\t\tconst matchStr = str.slice(startingCurlyIndex + 1, match.index);\n\n\t\t\tif (matchStr) {\n\t\t\t\tfor (let j = 0; j < snippets.length; j++) {\n\t\t\t\t\tconst snippet = snippets[j];\n\n\t\t\t\t\tif (snippet.from > startingCurlyIndex && snippet.to < match.index) {\n\t\t\t\t\t\tsnippets.splice(j, 1)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsnippets.push({\n\t\t\t\t\tfrom: startingCurlyIndex,\n\t\t\t\t\tto: match.index,\n\t\t\t\t\tmatch: `${start}${matchStr}${end}`,\n\t\t\t\t\texecutable: matchStr\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn snippets;\n}", "export function parseNodeDirective(node: Element, name: string, value: string): DirectiveValue{\n\tconst dot = name.indexOf('.');\n\tlet prop = null;\n\n\tif (dot >= 0) {\n\t\tprop = name.slice(dot + 1);\n\t\tname = name.slice(0, dot);\n\t}\n\n\treturn {name, value, prop};\n}\n", "export function evaluateStringInComponentContext(\n\texecutable: string,\n\tcomponent: WebComponent,\n\tnodeData: ObjectLiteral = {}\n) {\n\tif (!executable.trim()) {\n\t\treturn '';\n\t}\n\t\n\tconst ctx = component.$context;\n\tconst keys = Array.from(new Set([\n\t\t...Object.getOwnPropertyNames(nodeData),\n\t\t...Object.getOwnPropertyNames(ctx),\n\t\t...component.$properties\n\t]));\n\n\treturn (\n\t\tnew Function(...keys, `\"use strict\";\\n return ${executable};`)\n\t).apply(component, keys.map((key: string) => nodeData[key] ?? component[key] ?? ctx[key] ?? null)) ?? '';\n}\n", "import {evaluateStringInComponentContext} from \"./evaluate-string-in-component-context\";\n\nexport function resolveExecutable(component: WebComponent, nodeData: ObjectLiteral, {match, executable}: Executable, newValue: string) {\n\tlet res = evaluateStringInComponentContext(executable, component, nodeData);\n\n\tif (res && typeof res === 'object') {\n\t\ttry {\n\t\t\tres = JSON.stringify(res)\n\t\t} catch (e) {\n\t\t}\n\t}\n\n\treturn newValue.replace(match, res);\n}\n", "export function getComponentNodeEventListener(\n\tcomponent: WebComponent,\n\tname: string,\n\tvalue: string,\n\tprops: Array<string> = [],\n\tvalues: Array<unknown> = [],\n): EventListenerCallback | null {\n\tvalue = value.trim()\n\tconst match = value.match(/^(?:((?:this\\.)?([a-z$_][a-z0-9$_]*)\\s*\\((.*)\\))|\\{(.*)\\})$/i);\n\n\tif (match) {\n\t\tlet [_, fn, fnName, fnArgs, executable] = match;\n\n\t\tif (executable) {\n\t\t\tconst fn = new Function('$event', ...props, `\"use strict\";\\n return ${executable};`);\n\n\t\t\treturn (event: Event) => fn.call(component, event, ...values);\n\t\t} else {\n\t\t\tfn = fn.replace(/^this\\./, '');\n\t\t\tconst func = new Function('$event', ...props, `\"use strict\";\\n return this.${fn}`);\n\n\t\t\t// @ts-ignore\n\t\t\tif (typeof component[fnName] === 'function') {\n\t\t\t\treturn (event: Event) => func.call(component, event, ...values);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n", "import {getComponentNodeEventListener} from \"./get-component-node-event-listener\";\n\nexport function getEventHandlerFunction(component: WebComponent, nodeData: ObjectLiteral, attribute: Attr): EventListenerCallback | null {\n\tconst props = Array.from(new Set([...Object.getOwnPropertyNames(nodeData), ...component.$properties]));\n\tconst values = props.map(k => {\n\t\treturn nodeData[k] ?? component[k] ?? null;\n\t});\n\n\tconst fn = getComponentNodeEventListener(component, attribute.name, attribute.value, props, values);\n\n\tif (fn) {\n\t\treturn fn;\n\t} else {\n\t\tcomponent.onError(new Error(`${component.constructor.name}: Invalid event handler for \"${attribute.name}\" >>> \"${attribute.value}\".`))\n\t}\n\n\treturn null\n}\n", "import {extractExecutableSnippetFromString} from \"./utils/extract-executable-snippet-from-string\";\nimport {parseNodeDirective} from \"./utils/parse-node-directive\";\nimport {turnKebabToCamelCasing} from \"./utils/turn-kebab-to-camel-casing\";\nimport {resolveExecutable} from \"./utils/resolve-executable\";\nimport {getEventHandlerFunction} from \"./utils/get-event-handler-function\";\nimport {directiveRegistry} from './directives/registry';\nimport {evaluateStringInComponentContext} from \"./utils/evaluate-string-in-component-context\";\nimport {$} from \"./metadata\";\nimport {trackNode} from \"./utils/track-node\";\nimport {jsonParse} from \"./utils/json-parse\";\n\n/**\n * handles all logic related to tracking and updating a tracked node.\n * It is a extension of the component that handles all the logic related to updating nodes\n * in conjunction with the node component\n */\nexport class NodeTrack {\n\tnode: HTMLElement | Node;\n\tattributes: Array<{\n\t\tname: string;\n\t\tvalue: string;\n\t\texecutables: Array<Executable>;\n\t}> = []\n\tdirectives: Array<DirectiveValue> = [];\n\tproperty: {\n\t\tname: string;\n\t\tvalue: string;\n\t\texecutables: Array<Executable>;\n\t} = {\n\t\tname: '',\n\t\tvalue: '',\n\t\texecutables: []\n\t};\n\treadonly component: WebComponent;\n\tanchor: HTMLElement | Node | Comment | Array<Element>;\n\tempty = false;\n\ttracks = new Map();\n\treadonly dirAnchors = new WeakMap();\n\n\tconstructor(node: HTMLElement | Node, component: WebComponent) {\n\t\tthis.node = node;\n\t\tthis.anchor = node;\n\t\tthis.component = component;\n\n\t\t$.get(this.node).rawNodeString = /#text|#comment/.test(node.nodeName)\n\t\t\t? node.nodeValue\n\t\t\t: (node as HTMLElement).outerHTML;\n\n\t\tthis._setTracks();\n\n\t}\n\n\tget $context() {\n\t\treturn (this.anchor === this.node\n\t\t\t? $.get(this.node).$context\n\t\t\t: $.get((this.anchor as Array<Element>)[0] ?? this.anchor)?.$context) || {};\n\t}\n\n\tupdateNode() {\n\t\tlet directiveNode: any = this.node;\n\n\t\tfor (let directive of this.directives) {\n\t\t\tif (directive && directive.handler) {\n\t\t\t\ttry {\n\t\t\t\t\tconst {handler} = directive;\n\n\t\t\t\t\tlet val = handler.parseValue(directive.value, directive.prop);\n\t\t\t\t\textractExecutableSnippetFromString(val).forEach((exc) => {\n\t\t\t\t\t\tval = resolveExecutable(this.component, this.$context, exc, val);\n\t\t\t\t\t});\n\n\t\t\t\t\tconst value = evaluateStringInComponentContext(val, this.component, this.$context);\n\t\t\t\t\tdirectiveNode = handler.render(value, {\n\t\t\t\t\t\telement: this.node,\n\t\t\t\t\t\tanchorNode: this.dirAnchors.get(directive) ?? null,\n\t\t\t\t\t\trawElementOuterHTML: $.get(this.node).rawNodeString\n\t\t\t\t\t} as directiveRenderOptions);\n\n\t\t\t\t\tif (directiveNode !== this.node) {\n\t\t\t\t\t\tthis.dirAnchors.set(directive, directiveNode)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t} catch (e: any) {\n\t\t\t\t\tthis.component.onError(new Error(`\"${directive.name}\" on ${$.get(this.node).rawNodeString}: ${e.message}`));\n\t\t\t\t}\n\n\t\t\t\tthis.dirAnchors.set(directive, null)\n\t\t\t}\n\t\t}\n\n\t\tif (directiveNode === this.node) {\n\t\t\tthis.anchor = this._switchNodeAndAnchor(directiveNode);\n\n\t\t\tif (this.property?.executables.length) {\n\t\t\t\tconst newValue = this.property.executables.reduce((val, exc) => {\n\t\t\t\t\treturn resolveExecutable(this.component, this.$context, exc, val);\n\t\t\t\t}, this.property.value)\n\n\t\t\t\tif (newValue !== (this.node as ObjectLiteral)[this.property.name]) {\n\t\t\t\t\t(this.node as ObjectLiteral)[this.property.name] = newValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let {name, value, executables} of this.attributes) {\n\t\t\t\tif (executables.length) {\n\t\t\t\t\tlet newValue = executables.reduce((val, exc) => {\n\t\t\t\t\t\treturn resolveExecutable(this.component, this.$context, exc, val);\n\t\t\t\t\t}, value)\n\n\t\t\t\t\tconst camelName = turnKebabToCamelCasing(name);\n\n\t\t\t\t\tif ((this.node as ObjectLiteral)[camelName] !== undefined) {\n\t\t\t\t\t\tnewValue = jsonParse(newValue);\n\n\t\t\t\t\t\tif (newValue !== (this.node as ObjectLiteral)[camelName]) {\n\t\t\t\t\t\t\t(this.node as ObjectLiteral)[camelName] = newValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ((this.node as HTMLElement).getAttribute(name) !== newValue) {\n\t\t\t\t\t\t(this.node as HTMLElement).setAttribute(name, newValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.tracks.forEach((track) => {\n\t\t\t\ttrack.updateNode();\n\t\t\t});\n\n\t\t} else {\n\t\t\tthis.anchor = this._switchNodeAndAnchor(directiveNode);\n\t\t}\n\n\t\treturn directiveNode;\n\t}\n\n\tprivate _setTracks() {\n\t\tconst {nodeName, nodeValue, textContent, attributes} = this.node as HTMLElement;\n\t\tconst eventHandlers: Array<EventHandlerTrack> = [];\n\n\t\tif (nodeName === '#text') {\n\t\t\tthis.property = {\n\t\t\t\tname: 'nodeValue',\n\t\t\t\tvalue: nodeValue || '',\n\t\t\t\texecutables: []\n\t\t\t}\n\t\t} else {\n\t\t\tconst attrs = [];\n\t\t\tconst isRepeatedNode = (this.node as HTMLElement)?.hasAttribute('repeat');\n\n\t\t\tif (nodeName === 'TEXTAREA') {\n\t\t\t\tthis.property = {\n\t\t\t\t\tname: 'value',\n\t\t\t\t\tvalue: textContent || '',\n\t\t\t\t\texecutables: []\n\t\t\t\t}\n\t\t\t\tthis.node.textContent = '';\n\t\t\t} else if (nodeName === 'STYLE') {\n\t\t\t\tconst selectorPattern = /[a-z:#\\.*\\[][^{}]*[^\\s:]\\s*(?={){/gmi;\n\t\t\t\tconst propValueStylePattern = /[a-z][a-z-]*:([^;]*)(;|})/gmi;\n\t\t\t\tlet styleText = (textContent ?? '');\n\t\t\t\tlet match: RegExpExecArray | null = null;\n\t\t\t\tlet executables: Array<Executable> = [];\n\n\t\t\t\twhile ((match = selectorPattern.exec(styleText)) !== null) {\n\t\t\t\t\tlet propValueMatch: RegExpExecArray | null = null;\n\t\t\t\t\tlet propValue = styleText.slice(selectorPattern.lastIndex);\n\n\t\t\t\t\twhile ((propValueMatch = propValueStylePattern.exec(propValue)) !== null) {\n\t\t\t\t\t\texecutables.push(...extractExecutableSnippetFromString(propValueMatch[1], ['[', ']']))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (executables.length) {\n\t\t\t\t\tthis.property = {\n\t\t\t\t\t\tname: 'textContent',\n\t\t\t\t\t\tvalue: styleText,\n\t\t\t\t\t\texecutables\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// @ts-ignore\n\t\t\tfor (let attribute of [...attributes]) {\n\t\t\t\tif (/^(attr\\.|ref|if|repeat)/.test(attribute.name)) {\n\t\t\t\t\tconst directive = parseNodeDirective(this.node as HTMLElement, attribute.name, attribute.value);\n\n\t\t\t\t\tif (directiveRegistry[directive.name]) {\n\t\t\t\t\t\tconst Dir = directiveRegistry[directive.name];\n\t\t\t\t\t\tdirective.handler = new Dir(this.component);\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (directive.name) {\n\t\t\t\t\t\tcase 'if':\n\t\t\t\t\t\t\tthis.directives.unshift(directive);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'repeat':\n\t\t\t\t\t\t\tif (this.directives[0]?.name === 'if') {\n\t\t\t\t\t\t\t\tthis.directives.splice(1, 0, directive);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.directives.unshift(directive);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthis.directives.push(directive);\n\t\t\t\t\t}\n\n\t\t\t\t\t(this.node as Element).removeAttribute(attribute.name);\n\t\t\t\t} else if (attribute.name.startsWith('on')) {\n\t\t\t\t\teventHandlers.push({\n\t\t\t\t\t\teventName: attribute.name.slice(2).toLowerCase(),\n\t\t\t\t\t\tattribute\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tattrs.push(attribute)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\teventHandlers.forEach(({eventName, fn, attribute}) => {\n\t\t\t\t(this.node as HTMLElement).removeAttribute(attribute.name);\n\n\t\t\t\tif (!fn && !isRepeatedNode) {\n\t\t\t\t\tfn = getEventHandlerFunction(this.component, this.$context, attribute) as EventListenerCallback;\n\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\tthis.node.addEventListener(eventName, fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (let attr of attrs) {\n\t\t\t\tif (attr.value.trim()) {\n\t\t\t\t\tthis.attributes.push({\n\t\t\t\t\t\tname: attr.name,\n\t\t\t\t\t\tvalue: attr.value,\n\t\t\t\t\t\texecutables: extractExecutableSnippetFromString(attr.value)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.property?.value.trim() && !this.property.executables.length) {\n\t\t\tthis.property.executables = extractExecutableSnippetFromString(this.property.value)\n\t\t}\n\n\t\tthis.empty = !this.directives.length &&\n\t\t\t!this.attributes.some(attr => attr.executables.length) &&\n\t\t\t!this.property.executables.length;\n\t}\n\n\tprivate _createDefaultAnchor() {\n\t\treturn document.createComment(` ${this.node.nodeValue ?? (this.node as HTMLElement).outerHTML} `)\n\t}\n\n\tprivate _switchNodeAndAnchor(dirNode: HTMLElement | Node | Comment | Array<Element>) {\n\t\tif (dirNode === this.anchor) {\n\t\t\treturn dirNode;\n\t\t}\n\n\t\tlet dirIsArray = Array.isArray(dirNode);\n\n\t\tif (\n\t\t\t(dirIsArray && !(dirNode as Array<Element>).length) ||\n\t\t\t(!dirIsArray && !(/[831]/.test(`${(dirNode as Node).nodeType}`)))\n\t\t) {\n\t\t\tdirNode = this._createDefaultAnchor();\n\t\t\tdirIsArray = false;\n\t\t}\n\n\t\tconst anchorIsArray = Array.isArray(this.anchor);\n\t\tconst anchorEl = document.createComment('bfs')\n\t\tlet nextEl: Element | Comment | Text = anchorEl;\n\n\t\tif (anchorIsArray) {\n\t\t\t(this.anchor as Array<Element>)[0]?.parentNode?.insertBefore(nextEl, (this.anchor as Array<Element>)[0]);\n\t\t} else {\n\t\t\t(this.anchor as HTMLElement).before(nextEl);\n\t\t}\n\n\t\tif (dirIsArray) {\n\t\t\tfor (let el of (dirNode as Array<Element>)) {\n\t\t\t\tif (el.isConnected) {\n\t\t\t\t\tthis._deepUpdateNode(el);\n\t\t\t\t} else {\n\t\t\t\t\tnextEl.after(el);\n\t\t\t\t\tthis._trackNode(el);\n\t\t\t\t\t$.get(el).shadowNode = this.node;\n\t\t\t\t}\n\n\t\t\t\tnextEl = el;\n\t\t\t}\n\t\t} else {\n\t\t\tnextEl.after(dirNode as Node);\n\n\t\t\tif ($.has(dirNode)) {\n\t\t\t\tif (dirNode !== this.node) {\n\t\t\t\t\tthis._deepUpdateNode(dirNode as Node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._trackNode(dirNode as Node);\n\t\t\t}\n\t\t}\n\n\t\tif (anchorIsArray) {\n\t\t\tfor (let el of (this.anchor as Array<Element>)) {\n\t\t\t\tif (!dirIsArray || !(dirNode as Array<Element>).includes(el)) {\n\t\t\t\t\tel.parentNode?.removeChild(el);\n\t\t\t\t\tthis._unTrackNode(el);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.anchor !== dirNode) {\n\t\t\t(this.anchor as Node).parentNode?.removeChild(this.anchor as Node);\n\t\t\tthis._unTrackNode(this.anchor as Node);\n\t\t}\n\n\t\tanchorEl.parentNode?.removeChild(anchorEl);\n\n\t\tthis.anchor = dirNode;\n\n\t\treturn dirNode;\n\t}\n\n\tprivate _trackNode(n: Node) {\n\t\ttrackNode(n, this.component, {\n\t\t\tcustomSlot: this.component.customSlot,\n\t\t\tcustomSlotChildNodes: this.component.customSlot ? this.component._childNodes : [],\n\t\t\ttracks: this.tracks\n\t\t})\n\t}\n\n\tprivate _unTrackNode(n: Node) {\n\t\tif (n !== this.node) {\n\t\t\tthis.tracks.delete(n);\n\t\t\tn.childNodes.forEach(c => this._unTrackNode(c));\n\t\t}\n\t}\n\n\tprivate _deepUpdateNode(n: Node) {\n\t\t$.get(n)?.track?.updateNode();\n\t\tn.childNodes.forEach(c => this._deepUpdateNode(c));\n\t}\n\n}\n", "import {$} from \"../metadata\";\nimport {NodeTrack} from \"../node-track\";\nimport {defineNodeContextMetadata} from \"./define-node-context-metadata\";\n\nexport function trackNode(node: Node | HTMLElement | DocumentFragment, component: WebComponent, opt: trackerOptions) {\n\tconst {nodeName, nodeValue, childNodes, nodeType} = node;\n\n\tif ($.get(node)?.tracked || (nodeName === '#text' && !nodeValue?.trim())) {\n\t\treturn;\n\t}\n\n\tif (nodeType !== 11 && nodeName !== 'SLOT') {\n\t\tdefineNodeContextMetadata(node);\n\t}\n\n\tif (/#comment|SCRIPT/.test(nodeName)) {\n\t\treturn;\n\t}\n\n\tlet {customSlot = false, customSlotChildNodes = [], trackOnly = false, tracks} = opt\n\t\n\tif (nodeName === 'SLOT') {\n\t\tif (customSlot) {\n\t\t\treturn renderCustomSlot(node as HTMLSlotElement, customSlotChildNodes)\n\t\t\t\t.forEach((child: Node) => trackNode(child, component, opt));\n\t\t}\n\t\t\n\t\tnode.addEventListener('slotchange', () => {\n\t\t\t(node as HTMLSlotElement).assignedNodes().forEach((n: HTMLElement | Node) => {\n\t\t\t\ttrackNode(n, component, opt);\n\t\t\t});\n\t\t});\n\t\t\n\t\tchildNodes.forEach((n: HTMLElement | Node) => {\n\t\t\ttrackNode(n, component, opt);\n\t\t});\n\t} else {\n\t\t// avoid fragments\n\t\tif (nodeType !== 11) {\n\t\t\tif (nodeType === 1 || nodeName === '#text') {\n\t\t\t\tconst track: NodeTrack = new NodeTrack(node, component);\n\t\t\t\tif (!track.empty) {\n\t\t\t\t\t$.get(node).track = track;\n\t\t\t\t\ttracks.set(node, track);\n\n\t\t\t\t\tif (!trackOnly) {\n\t\t\t\t\t\tconst res = track.updateNode();\n\t\t\t\t\t\tif (res !== node) {\n\t\t\t\t\t\t\ttrackOnly = true;\n\n\t\t\t\t\t\t\tif (Array.isArray(res)) {\n\t\t\t\t\t\t\t   return;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks = track.tracks;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$.get(node).tracked = true;\n\t\t\t\n\t\t\tif (/#text|TEXTAREA|STYLE/.test(nodeName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tArray.from(childNodes).forEach(c => trackNode(c, component, {...opt, trackOnly, tracks}));\n\t}\n}\n\nfunction renderCustomSlot(node: HTMLSlotElement, childNodes: Array<Node>) {\n\tconst name = node.getAttribute('name');\n\tlet nodeList: any;\n\tlet comment = document.createComment(`slotted [${name || ''}]`);\n\tnode.parentNode?.replaceChild(comment, node);\n\t\n\tif (name) {\n\t\tnodeList = childNodes.filter(n => {\n\t\t\treturn n.nodeType === 1 && (n as HTMLElement).getAttribute('slot') === name;\n\t\t});\n\t} else {\n\t\tnodeList = childNodes.filter(n => {\n\t\t\treturn n.nodeType !== 1 || !(n as HTMLElement).hasAttribute('slot');\n\t\t});\n\t}\n\t\n\tif (!nodeList.length) {\n\t\tnodeList = node.childNodes;\n\t}\n\t\n\tlet anchor = comment;\n\t\n\tfor (let n of nodeList) {\n\t\tanchor.after(n);\n\t\tanchor = n;\n\t}\n\t\n\tcomment.parentNode?.removeChild(comment);\n\t\n\treturn nodeList;\n}\n", "// simply importing directive here will automatically register them and make them available for\n// anything later on\nimport './directives';\nimport booleanAttr from './utils/boolean-attributes.json';\nimport {$} from \"./metadata\";\nimport {parse} from './utils/parse';\nimport {setComponentPropertiesFromObservedAttributes} from './utils/set-component-properties-from-observed-attributes';\nimport {setupComponentPropertiesForAutoUpdate} from './utils/setup-component-properties-for-auto-update';\nimport {turnCamelToKebabCasing} from './utils/turn-camel-to-kebab-casing';\nimport {turnKebabToCamelCasing} from './utils/turn-kebab-to-camel-casing';\nimport {getStyleString} from './utils/get-style-string';\nimport {ShadowRootModeExtended} from \"./enums/ShadowRootModeExtended.enum\";\nimport {trackNode} from \"./utils/track-node\";\nimport {jsonParse} from \"./utils/json-parse\";\nimport {defineNodeContextMetadata} from \"./utils/define-node-context-metadata\";\n\n/**\n * a extension on the native web component API to simplify and automate most of the pain points\n * when it comes to creating and working with web components on the browser\n */\nexport class WebComponent extends HTMLElement {\n\treadonly $refs: Refs = {};\n\t$properties: Array<string> = ['$context', '$refs'];\n\ttemplateId = '';\n\t_childNodes: Array<Node> = [];\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tif (!$.has(this)) {\n\t\t   defineNodeContextMetadata(this)\n\t\t}\n\n\t\tconst meta = $.get(this);\n\n\t\tmeta.root = this;\n\t\tmeta.mounted = false;\n\t\tmeta.parsed = false;\n\t\tmeta.contextSource = null;\n\t\tmeta.tracks = new Map();\n\t\tmeta.contextSubscribers = [];\n\t\tmeta.unsubscribeCtx = () => {};\n\n\t\t// @ts-ignore\n\t\tlet {mode, observedAttributes, delegatesFocus, initialContext} = this.constructor;\n\n\t\tif (mode !== 'none') {\n\t\t\t$.get(this).root = this.attachShadow({mode, delegatesFocus});\n\t\t}\n\n\t\t$.get(this).updateContext(initialContext);\n\n\t\tthis.$properties.push(\n\t\t\t...setComponentPropertiesFromObservedAttributes(this, observedAttributes,\n\t\t\t\t(prop, oldValue, newValue) => {\n\t\t\t\t\tthis.forceUpdate();\n\n\t\t\t\t\tif (this.mounted) {\n\t\t\t\t\t\tthis.onUpdate(prop, oldValue, newValue);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * an array of attribute names as they will look in the html tag\n\t * https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elementsusing_the_lifecycle_callbacks\n\t * @type {[]}\n\t */\n\tstatic observedAttributes: Array<string> = [];\n\n\t/**\n\t * shadow root mode\n\t * https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/mode\n\t * plus an additional option of \"none\" to signal you dont want\n\t * the content to be places inside the shadow root but directly under the tag\n\t * @type {string}\n\t */\n\tstatic mode = ShadowRootModeExtended.OPEN;\n\n\t/**\n\t * shadow root delegate focus option\n\t * https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/delegatesFocus\n\t * @type {boolean}\n\t */\n\tstatic delegatesFocus = false;\n\n\t/**\n\t * a valid name of the html tag\n\t * @type {string}\n\t */\n\tstatic tagName = '';\n\n\t/**\n\t * the initial context data for the component\n\t */\n\tstatic initialContext = {};\n\n\t/**\n\t * parses special template HTML string taking in consideration\n\t * all the additional syntax specific to this framework\n\t */\n\tstatic parseHTML(markup: string): DocumentFragment {\n\t\treturn parse(markup)\n\t}\n\n\t/**\n\t * registers the component with the CustomElementRegistry taking an optional tag name if not\n\t * specified as static member of the class as tagName\n\t * @param tagName\n\t */\n\tstatic register(tagName?: string | undefined) {\n\t\ttagName = typeof tagName === 'string' && tagName\n\t\t\t? tagName\n\t\t\t: typeof this.tagName === 'string' && this.tagName\n\t\t\t\t? this.tagName\n\t\t\t\t: turnCamelToKebabCasing(this.name);\n\n\t\tthis.tagName = tagName;\n\n\t\tif (!customElements.get(tagName)) {\n\t\t\tcustomElements.define(tagName, this);\n\t\t}\n\t}\n\n\t/**\n\t * registers a list of provided web component classes\n\t * @param components\n\t */\n\tstatic registerAll(components: Array<WebComponentConstructor>) {\n\t\tcomponents.forEach(comp => comp.register());\n\t}\n\n\t/**\n\t * returns whether the component is registered or not\n\t */\n\tstatic get isRegistered() {\n\t\treturn customElements.get(this.tagName) !== undefined;\n\t}\n\n\t/**\n\t * whether or not the component should use the real slot element or mimic its behavior\n\t * when rendering template\n\t */\n\tget customSlot() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * the root element. If shadow root present it will be the shadow root otherwise\n\t * the actual element\n\t * @returns {*}\n\t */\n\tget root(): HTMLElement | ShadowRoot | null {\n\t\treturn (this.constructor as WebComponentConstructor).mode === 'closed' ? null : $.get(this).root;\n\t}\n\n\t/**\n\t * whether or not the element is attached to the DOM and works differently than Element.isConnected\n\t * @returns {boolean}\n\t */\n\tget mounted() {\n\t\treturn $.get(this).mounted;\n\t}\n\n\t/**\n\t * style for the component whether inside the style tag, as object or straight CSS string\n\t * @returns {string | {type: string, content: string}}\n\t */\n\tget stylesheet() {\n\t\treturn '';\n\t}\n\n\t/**\n\t * template for the element HTML content\n\t * @returns {string}\n\t */\n\tget template() {\n\t\treturn '';\n\t}\n\n\tget $context(): ObjectLiteral {\n\t\t// make sure the subscribe method is part of the prototype\n\t\t// so it is hidden unless the prototype is checked\n\t\treturn Object.setPrototypeOf({\n\t\t\t...$.get(this).contextSource?.$context, // context from the nearest ancestor component\n\t\t\t...$.get(this).$context, // context from the component node itself\n\t\t}, {\n\t\t\tsubscribe: ctxSubscriberHandler($.get(this).contextSubscribers),\n\t\t});\n\t}\n\n\tget parsed() {\n\t\treturn $.get(this).parsed;\n\t}\n\n\tupdateContext(ctx: ObjectLiteral) {\n\t\t$.get(this).updateContext(ctx);\n\n\t\tif (this.mounted) {\n\t\t\tthis.forceUpdate();\n\t\t\t$.get(this).contextSubscribers.forEach((cb: (ctx: {}) => void) => cb($.get(this).$context));\n\t\t}\n\t}\n\n\tconnectedCallback() {\n\t\tconst {parsed} = $.get(this);\n\t\ttry {\n\t\t\t// @ts-ignore\n\t\t\t$.get(this).contextSource = getClosestWebComponentAncestor(this);\n\n\t\t\tif ($.get(this).contextSource) {\n\t\t\t\t// force update the component if the ancestor context gets updated as well\n\t\t\t\t$.get(this).unsubscribeCtx = $.get(this).contextSource.$context.subscribe((newContext: ObjectLiteral) => {\n\t\t\t\t\tthis.forceUpdate();\n\n\t\t\t\t\tif (this.mounted) {\n\t\t\t\t\t\tthis.onUpdate('$context', $.get(this).$context, newContext)\n\t\t\t\t\t}\n\n\t\t\t\t\t$.get(this).contextSubscribers.forEach((cb: (ctx: {}) => void) => cb(newContext));\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t/*\n\t\t\tonly need to parse the element the very first time it gets mounted\n\n\t\t\tthis will make sure that if the element is removed from the dom and mounted again\n\t\t\tall that needs to be done if update the DOM to grab the possible new context and updated data\n\t\t\t */\n\t\t\tif (parsed) {\n\t\t\t\tthis.forceUpdate();\n\t\t\t} else {\n\t\t\t\tthis.$properties.push(\n\t\t\t\t\t...setupComponentPropertiesForAutoUpdate(this, (prop, oldValue, newValue) => {\n\t\t\t\t\t\tthis.forceUpdate();\n\n\t\t\t\t\t\tif (this.mounted) {\n\t\t\t\t\t\t\tthis.onUpdate(prop, oldValue, newValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\n\t\t\t\tObject.freeze(this.$properties);\n\n\t\t\t\tlet contentNode;\n\t\t\t\tconst hasShadowRoot = (this.constructor as WebComponentConstructor).mode !== 'none';\n\t\t\t\tconst style = getStyleString(this.stylesheet, (this.constructor as WebComponentConstructor).tagName, hasShadowRoot);\n\t\t\t\tlet temp: string = this.template;\n\n\t\t\t\tif (!temp && this.templateId) {\n\t\t\t\t\tconst t = document.getElementById(this.templateId);\n\n\t\t\t\t\ttemp = t?.nodeName === 'TEMPLATE' ? t.innerHTML : temp;\n\t\t\t\t}\n\n\t\t\t\tcontentNode = parse(style + temp);\n\n\t\t\t\tthis._childNodes = Array.from(this.childNodes);\n\n\t\t\t\tif (this.customSlot) {\n\t\t\t\t\tthis.innerHTML = '';\n\t\t\t\t}\n\n\t\t\t\ttrackNode(contentNode, this, {\n\t\t\t\t\tcustomSlot: this.customSlot,\n\t\t\t\t\tcustomSlotChildNodes: this.customSlot ? this._childNodes : [],\n\t\t\t\t\ttracks: $.get(this).tracks,\n\t\t\t\t});\n\n\t\t\t\tconst {tagName, mode} = (this.constructor as WebComponentConstructor);\n\n\t\t\t\tif (mode === 'none') {\n\t\t\t\t\tconst styles = contentNode.querySelectorAll('style');\n\n\t\t\t\t\tstyles.forEach((style: HTMLStyleElement) => {\n\t\t\t\t\t\tconst existingStyleElement: HTMLStyleElement | null = document.head.querySelector(`style.${tagName}`);\n\n\t\t\t\t\t\tif (existingStyleElement) {\n\t\t\t\t\t\t\texistingStyleElement.textContent = `${style?.textContent}${existingStyleElement.textContent}`;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdocument.head.appendChild(style);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t$.get(this).parsed = true;\n\t\t\t\t$.get(this).root.appendChild(contentNode);\n\t\t\t}\n\n\t\t\t$.get(this).mounted = true;\n\t\t\tthis.onMount();\n\t\t} catch (e) {\n\t\t\tthis.onError(e as ErrorEvent);\n\t\t}\n\t}\n\n\t/**\n\t * livecycle callback for when the element is attached to the DOM\n\t */\n\tonMount() {\n\t}\n\n\tdisconnectedCallback() {\n\t\ttry {\n\t\t\t$.get(this).contextSource = null;\n\t\t\t$.get(this).mounted = false;\n\t\t\t$.get(this).unsubscribeCtx();\n\t\t\tthis.onDestroy();\n\t\t} catch (e) {\n\t\t\tthis.onError(e as Error)\n\t\t}\n\t}\n\n\t/**\n\t * livecycle callback for when the element is removed from the DOM\n\t */\n\tonDestroy() {\n\t}\n\n\tattributeChangedCallback(name: string, oldValue: any, newValue: any) {\n\t\ttry {\n\t\t\tif (!(name.startsWith('data-') || name === 'class' || name === 'style')) {\n\t\t\t\tconst prop: any = turnKebabToCamelCasing(name);\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis[prop] = booleanAttr.hasOwnProperty(prop)\n\t\t\t\t\t? this.hasAttribute(name)\n\t\t\t\t\t: jsonParse(newValue);\n\t\t\t} else {\n\t\t\t\tthis.forceUpdate();\n\n\t\t\t\tif (this.mounted) {\n\t\t\t\t\tthis.onUpdate(name, oldValue, newValue);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis.onError(e as ErrorEvent)\n\t\t}\n\t}\n\n\t/**\n\t * livecycle callback for when the element attributes or class properties are updated\n\t */\n\tonUpdate(name: string, oldValue: unknown, newValue: unknown) {\n\t}\n\n\t/**\n\t * updates any already tracked node with current component data including context and node level data.\n\t */\n\tforceUpdate() {\n\t\t$.get(this).tracks.forEach((t: NodeTrack) => {\n\t\t\tt.updateNode();\n\t\t});\n\t\treturn true;\n\t}\n\n\tadoptedCallback() {\n\t\ttry {\n\t\t\tthis.onAdoption();\n\t\t} catch (e) {\n\t\t\tthis.onError(e as Error)\n\t\t}\n\t}\n\n\t/**\n\t * livecycle callback for when element is moved into a new document\n\t */\n\tonAdoption() {\n\t}\n\n\t/**\n\t * error callback for when an error occurs\n\t */\n\tonError(error: ErrorEvent | Error) {\n\t\tconsole.error(this.constructor.name, error);\n\t}\n}\n\nfunction ctxSubscriberHandler(subs: Array<ObserverCallback>) {\n\treturn (cb: ObserverCallback) => {\n\t\tsubs.push(cb);\n\t\treturn () => {\n\t\t\tsubs = subs.filter((c: ObserverCallback) => c !== cb);\n\t\t}\n\t}\n}\n\nfunction getClosestWebComponentAncestor(component: WebComponent): WebComponent | null {\n\tlet parent = component.parentNode;\n\n\twhile (parent && !(parent instanceof WebComponent)) {\n\t\tparent = parent instanceof ShadowRoot ? parent.host : parent.parentNode;\n\t}\n\n\treturn parent instanceof WebComponent ? parent : null;\n}\n\n", "import {ShadowRootModeExtended} from \"./enums/ShadowRootModeExtended.enum\";\nimport {WebComponent} from \"./web-component\";\n\n/**\n * a special WebComponent that handles slot tag differently allowing for render template right into HTML files\n */\nexport class ContextProviderComponent extends WebComponent {\n\tget customSlot() {\n\t\treturn true;\n\t}\n\n\tstatic mode = ShadowRootModeExtended.NONE;\n\t\n\tget template() {\n\t\treturn '<slot></slot>';\n\t}\n}\n", "// @beforesemicolon/web-component, copyright (c) by Elson Correia\n// Distributed under an MIT license: https://github.com/beforesemicolon/web-component/blob/master/LICENSE\n\nimport {WebComponent} from './web-component';\nimport {Directive} from './directive';\nimport {ContextProviderComponent} from './context-provider-component';\n\n// @ts-ignore\nif (window) {\n\t// @ts-ignore\n\twindow.WebComponent = WebComponent;\n\t// @ts-ignore\n\twindow.ContextProviderComponent = ContextProviderComponent;\n\t// @ts-ignore\n\twindow.Directive = Directive;\n}\n"],
  "mappings": "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",
  "names": []
}
